<!doctype html><html lang=en><head><meta http-equiv=refresh content="0; url=https://forge.rust-lang.org/compiler/index.html"></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://rust-lang.github.io/compiler-team/>Rust Lang - Compiler Team</a></h2><style>nav ul a[href$=\2f compiler-team\2fminutes\2f design-meeting\2f 2019-10-11-DepGraph-persistence-PR62038\2f ]{color:#004ed0}</style><ul><li><p><strong>About</strong></p><ul><li><a href=/compiler-team/about/CODE_OF_CONDUCT/>Code of Conduct</a></li><li><a href=/compiler-team/about/chat-platform/>Chat Platform</a></li><li><a href=/compiler-team/about/steering-meeting/>Steering Meeting</a></li><li><a href=/compiler-team/about/triage-meeting/>Triage Meeting</a></li></ul></li><li><p><strong>Minutes</strong></p><ul><li><a href=/compiler-team/minutes/design-meeting/>Design Meetings</a></li><li><a href=/compiler-team/minutes/steering-meeting/>Steering Meetings</a></li><li><a href=/compiler-team/minutes/triage-meeting/>Triage Meetings</a></li></ul></li><li><p><strong>Procedures</strong></p><ul><li><a href=/compiler-team/procedures/>Documentation</a></li><li><a href=/compiler-team/procedures/crates/>Crates</a></li><li><a href=/compiler-team/procedures/call-for-participation/>Call for participation</a></li><li><a href=/compiler-team/procedures/form-new-working-group/>Form new working group</a></li></ul></li><li><p><a href=/compiler-team/working-groups/><strong>Working Groups</strong></a></p><ul><li><a href=/compiler-team/working-groups/async-await/>Async Await</a></li><li><a href=/compiler-team/working-groups/debugging/>Debugging</a></li><li><a href=/compiler-team/working-groups/diagnostics/>Diagnostics</a></li><li><a href=/compiler-team/working-groups/rustc-dev-guide/>Rustc Dev Guide</a></li><li><a href=/compiler-team/working-groups/llvm/>LLVM</a></li><li><a href=/compiler-team/working-groups/meta/>Meta</a></li><li><a href=/compiler-team/working-groups/mir-opt/>MIR-opt</a></li><li><a href=/compiler-team/working-groups/nll/>NLL</a></li><li><a href=/compiler-team/working-groups/parallel-rustc/>parallel rustc</a></li><li><a href=/compiler-team/working-groups/pgo/>PGO</a></li><li><a href=/compiler-team/working-groups/pipelining/>pipelining</a></li><li><a href=/compiler-team/working-groups/polonius/>polonius</a></li><li><a href=/compiler-team/working-groups/polymorphization/>polymorphization</a></li><li><a href=/compiler-team/working-groups/prioritization/>Prioritization</a></li><li><a href=/compiler-team/working-groups/rfc-2229/>rfc-2229</a></li><li><a href=/compiler-team/working-groups/rls-2.0/>rls-2.0</a></li><li><a href=/compiler-team/working-groups/self-profile/>Self Profile</a></li><li><a href=/compiler-team/working-groups/traits/>Traits</a></li></ul></li></ul></nav></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/compiler-team/svg/menu.svg alt=Menu>
</label><strong>Dep-graph loading (#62083)</strong></header><article class=markdown><h1 id=design-meeting-2019-10-11>design meeting 2019-10-11</h1><p><a href=https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-11>Zulip stream</a></p><h2 id=introduction>introduction</h2><p>Dear @<em>T-compiler/meeting</em>,</p><p>Today we will be having a <strong>design meeting</strong>. The topic was originally sketched as &ldquo;some Zoxc PR&rdquo;. We&rsquo;ve since narrowed that down to discuss #62038, which is a refactoring to how dep-graph loading occurs. @<strong>Zoxc</strong> <a href=https://github.com/rust-lang/rust/pull/62038#issuecomment-540508308>wrote up a comment</a> giving a summary of the ideas. Note that this PR itself is an incremental step towards #60035, which aims to make dep-graph loading/saving more continuous.</p><p>I&rsquo;d also like to discuss briefly how we should document these changes. We currently have some rustc-chapters on incremental compilation (e.g., <a href=https://rustc-dev-guide.rust-lang.org/queries/incremental-compilation-in-detail.html>this chapter goes into detail</a>). I would like to move us to a world where major refactorings like #60035 (but not limited to this one &ndash; I think e.g. <a href=https://github.com/rust-lang/rust/pull/65232>my recent PR</a> and work on lazy norm fits the bill) come along with a rustc-dev-guide chapter that documents the new state of the world. Maybe we discuss some how that might work and &ndash; in the case of THIS PR &ndash; who might do that documentation work (I don&rsquo;t necessarily think it has to be @<strong>Zoxc</strong>, though they&rsquo;re also an obvious candidate). (In my ideal world, drafts of that chapter would be available <em>before</em> the PR, but at minimum I think such a chapter should be in place to help with reviewing.)</p><h2 id=questions-for-discussion>Questions for discussion</h2><ul><li>&ldquo;This is where the performance gain of this PR is.&rdquo;, have we measured this at all? &ndash; nikomatsakis<ul><li><a href="https://perf.rust-lang.org/compare.html?start=4a365a29d64bec75d107214319a129ba68fc12a3&amp;end=7830caefb62c9c8d3fb7a742c66c64c89bf3aafe&amp;stat=wall-time">Here are some measurements</a>. However, are they done against a single-threaded or parallel compiler? -mw</li><li>The results show some improvements and some regressions.</li></ul></li><li>&ldquo;The one possible performance drawback is that ids can become fragmented since this PR requires us to reuse ids from the previous session.&rdquo; &ndash; in what way is this a performance drawback? Do we have any mechanism to reuse ids or &lsquo;reset&rsquo; state after a suitable amount of time?</li><li>There is another possible performance drawback: The current dep-graph has to be built two times in the worst case (i.e. full cache, but all invalid). Is that correct?</li></ul><h2 id=minutes-and-notes-from-discussion>Minutes and notes from discussion</h2><ul><li>Review of how existing dep-nodes work<ul><li><a href=https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-11/near/177910369>Discussion about the color scheme</a></li><li><a href=https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-11/near/177910794>Brief notes about parallelism</a></li><li><a href=https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-11/near/177911022>Notes on how dep-graph works today</a></li></ul></li><li>Questions about the PR<ul><li><a href=https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-11/near/177911184>Key idea: change is to load up the old graph and use it as the starting point, editing it in place, rather than copying things out from it into the new graph</a></li><li><a href=https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-11/near/177911307>Deleting nodes and garbage</a><ul><li>when we load nodes, they have no color</li><li>if at the end of compilation they still have no color, we can delete them</li><li>we keep a &ldquo;free list&rdquo; for indices so they can get re-used</li></ul></li><li>However:<ul><li>we never shrink the graph as a whole, so if there used to be a lot of ids, we will keep the graph the same size<ul><li><a href=https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-11/near/177912057>in particular there could be an exceptional execution that creates a lot of nodes</a></li></ul></li><li>ids may also become fragmented over time</li></ul></li><li><a href=https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-11/near/177912273>How could we address this?</a><ul><li>some form of &ldquo;compression&rdquo; step when writing back to disk</li><li>complication: query-result-cache uses ids as keys<ul><li><a href=https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-11/near/177912399>&ldquo;if we want to garbage collect them, it must be done in sync with the query result cache&rdquo;</a></li></ul></li></ul></li></ul></li><li><a href=https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/design.20meeting.202019-10-11/near/177915151>Conclusions</a><ul><li>We had a good discussion of the PR in question. I don&rsquo;t think we raised any red flags or anything, the approach seems solid.</li><li>The real question is whether we want to move in he <strong>overall direction</strong> proposed by #60035</li><li>The goal here is to reduce the cost of loading/saving the dep-graph</li><li>#60035 proposed to do so by incrementally dumping out changed nodes and not retaining them in memory</li><li>This we barely touched on &ndash; some open questions for me<ul><li>Are there alternative designs we have in mind?</li><li>Is #60035 itself an &ldquo;end state&rdquo; or a stepping stone?</li></ul></li><li>Conclusion:<ul><li>Follow-up meeting to dig into design of #60035 and maybe discuss alternatives</li><li>In parallel, Niko will review #62038 now that he understands roughly what it is trying to do<ul><li>We would also want to write docs for rustc-dev-guide</li><li>We can figure out how that happens in parallel</li></ul></li></ul></li></ul></li></ul></article></div><aside class="book-toc level-6 fixed"><nav id=TableOfContents><ul><li><a href=#introduction>introduction</a></li><li><a href=#questions-for-discussion>Questions for discussion</a></li><li><a href=#minutes-and-notes-from-discussion>Minutes and notes from discussion</a></li></ul></nav></aside></main></body></html>