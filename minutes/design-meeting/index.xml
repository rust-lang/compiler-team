<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design meeting on Rust Lang - Compiler Team</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/</link><description>Recent content in Design meeting on Rust Lang - Compiler Team</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://rust-lang.github.io/compiler-team/minutes/design-meeting/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-01-streaming-dep-graph-proposal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-01-streaming-dep-graph-proposal/</guid><description>&amp;ldquo;Streaming dep graph&amp;rdquo; proposal Summary of the proposal Currently, incremental compilation begins by loading the old dependency graph and then &amp;ndash; as execution proceeds &amp;ndash; building a new dependency graph in memory. At the end of compilation, this new graph is written out.
PR #60035 proposes to change how the new graph is handled. Instead of building the graph in memory and writing it out at the end, we &amp;ldquo;stream&amp;rdquo; out a series of changes to the dep-graph as we go.</description></item><item><title>2019-12-06 end-to-end query PRs</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-12-06-end-to-end-query-PRs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-12-06-end-to-end-query-PRs/</guid><description>Design Meeting 2019-12-06 &amp;ndash; librustc_interface queries Links Zulip topic of the discussion Compiler team issue Pre-design meeting Zulip topic Internals thread with descriptions of PRs Background Goal is end-to-end queries Benefits: Simpler overall model Incremental extending back to parsing mw has done measurements suggesting that on larger crates some 40% of the compilation time comes from Parallel compilation would be more effective, if done on the basis of queries Agenda Tough to frame:) Most important question to settle is what overall stategy we plan to take Do we want to try and land / rebase these PRs?</description></item><item><title>2019-12-20 major changes process</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-12-20-major-change-process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-12-20-major-change-process/</guid><description>Major Change Process Zulip thread Summary We want some kind of system where people advertise changes that they are making or plan to make and the team can give high-level feedback early and &amp;ndash; if we decide to go with the change &amp;ndash; we can ensure there is a reviewer beforehand This document describes motivations and a specific &amp;ldquo;early draft&amp;rdquo; proposal Motivations Proposal is to add some sort of notification / lightweight process before making major changes.</description></item><item><title>2020-02-28 focused and efficient triage</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-02-28-focused-and-efficient-triage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-02-28-focused-and-efficient-triage/</guid><description>Focused and Efficient Triage Meeting proposal Pre-meeting notes Zulip meeting thread The goal of the meeting was to discuss the idea of creating a pre-triage working group, the tasks we need to do and who should be doing them. The motivation is that (a) a lot of work for our current triage process is falling on @pnkfelix and (b) there is a kind of lack of clarity around our goals, how we use our labels, etc.</description></item><item><title>2020-03-12 shared library to represent Rust types</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-03-12-shared-library-for-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-03-12-shared-library-for-types/</guid><description>Shared library to represent Rust types Notes from the meeting The later sections of this document were largely prepared before the discussion. This section contains notes from the discussion itself. You can also read the complete discussion in our zulip-archive.
Conclusions consensus from folks in the meeting: are &amp;ldquo;cautiously optimistic&amp;rdquo; about this approach, and open to us trying to create PRs that move rustc in this direction are ok with having a rusc-ty library that is published to crates.</description></item><item><title>2020-04-03 Cranelift backend for rustc</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-04-03-cranelift-backend-for-rustc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-04-03-cranelift-backend-for-rustc/</guid><description>Cranelift backend for rustc You can also read the complete discussion in our zulip-archive.
Meeting Proposal
Pre-meeting details and agenda outline
Overview of the Cranelift backend Cranelift is a code generation backend written in Rust which is under development for use in WebAssembly compilers. As such, it could potentially improve compilation times in rustc because it is optimized for efficiently generating code rather than generating efficient code.
Over the past ~1.</description></item><item><title>2020-05-29 Roadmap 2020-2021</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-05-29-Roadmap-2020-2021/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-05-29-Roadmap-2020-2021/</guid><description>Links Zulip topic Meeting proposal: rust-lang/compiler-team#287 Key notes and points from the meeting itself Parallel compilation: There was a general consensus to deprioritize parallel compilation in favor of pursuing better improvements to incremental compilation. One interesting use case is CI turnaround times. Parallel compilation doesn&amp;rsquo;t do much there since most CI systems are not very beefy. Incremental doesn&amp;rsquo;t either, but it might if you enabled incremental support (and could trust it well enough).</description></item><item><title>2020-09-18 Major Change Proposal Retrospective</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-09-18-mcp-retrospective/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-09-18-mcp-retrospective/</guid><description>Links Zulip topic Meeting proposal: rust-lang/compiler-team#314 Key notes and points from the meeting itself Feedback on MCPs after being seconded can be difficult to deal with. (link)
Some feelings of &amp;ldquo;where were you a week ago&amp;rdquo; as aluded to above We do want to encourage feedback even if it&amp;rsquo;s late but we should weigh some kinds of feedback more heavily than others &amp;ldquo;late&amp;rdquo; in the process. Most common feedback was: (link)</description></item><item><title>Debugging Support</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-18-debuginfo-meeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-18-debuginfo-meeting/</guid><description>Debugging Support in the Compiler Zulip stream or read on the Zulip archive The problems https://github.com/rust-lang/rust/issues/64343
We have bugs with debuginfo that are causing broad pain for people who use x.py test, but we do not have dedicated developers who own maintenance of debugger support.
https://github.com/rust-lang/rust/pull/60826
We have Pull Requests to improve our debuginfo support, but we do not have dedicated developers who own maintenance of debugger support.
Q: Are we willing/able to maintain debuginfo stuff Q: if we don&amp;rsquo;t, then can we afford to keep these tests?</description></item><item><title>Dep-graph loading (#62083)</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-11-DepGraph-persistence-PR62038/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-11-DepGraph-persistence-PR62038/</guid><description>design meeting 2019-10-11 Zulip stream
introduction Dear @T-compiler/meeting,
Today we will be having a design meeting. The topic was originally sketched as &amp;ldquo;some Zoxc PR&amp;rdquo;. We&amp;rsquo;ve since narrowed that down to discuss #62038, which is a refactoring to how dep-graph loading occurs. @Zoxc wrote up a comment giving a summary of the ideas. Note that this PR itself is an incremental step towards #60035, which aims to make dep-graph loading/saving more continuous.</description></item><item><title>Place Interning</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-27-place-interning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-27-place-interning/</guid><description>Place projection interning meeting 2019-09-27 Zulip stream
Ideas to pursue at some later point or in parallel removing the field from the projections get rid of static from PlaceBase I (oli-obk) think this would be good to pursue ealier than later since it&amp;rsquo;ll just eliminate an annoying piece that we don&amp;rsquo;t really care about most of the time intern entire places at the MIR level interning (base, Vec&amp;lt;projection&amp;gt;) means less re-use overall though nice hack: rfirst 128 (eddyb suggests 2^16) locals or so can be mapped to themselves could even be extended for whatever the most common projections are if that proves useful insert gratuitous reference to random compression methods here Ideas rejected intern the Vec&amp;lt;Projection&amp;gt; to a &amp;amp;[Projection] Rejected: List is better because it is smaller, and we can use a PlaceRef for cases where you want to do subslicing Although &amp;amp;[Projection] would mean that a.</description></item><item><title>Planning the gcx, tcx transition</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-06-21-the-gcx-tcx-transition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-06-21-the-gcx-tcx-transition/</guid><description>Planning the 'gcx, 'tcx transition Zulip thread Summary Discuss the end-state for tcx Plan the steps we will take to get there and time frame Motivation Now that we have removed the per-inference context interners, we plan to transition the compiler to a different naming scheme. This is a major shift and something we should plan carefully.
Also, it&amp;rsquo;s an opportunity to consider an alternate naming scheme &amp;ndash; tcx and 'tcx is not known to be particularly popular.</description></item><item><title>Read-Eval-Print-Loop (REPL) Extensions</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-29-repl-meeting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-29-repl-meeting/</guid><description>Zulip stream or read on the Zulip archive. Agenda Design doc: https://hackmd.io/GJokfI0wQ0i4SIgRbFTmfw
Big picture overview and questions
Essential changes to support REPL extensions
Big picture overview of design, and on-the-fly questions about it Read (to an AST), Compile (AST to MIR), Eval (the MIR to a value), Print (the value). and Loop.
Question: Is this going to be a tool analogous to miri, where check-in&amp;rsquo;s that break it may not break CI immediately, but rather will just file follow-up bugs?</description></item><item><title>Roadmap 2020</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-04-Roadmap-2020-Goals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-10-04-Roadmap-2020-Goals/</guid><description>Roadmap 2020 Compiler Discussion Zulip topic
2019 roadmap (for reference) The compiler team has five main themes of work for this year:
Improving &amp;ldquo;core strength&amp;rdquo; by lowering raw compilation times and also generating better code (which in turn can help with compilation times) Improved IDE integration, including support for typed completions Extracting parts of rustc into libraries, which are easier to understand and maintain but also help in developing a Rust specification Supporting lang team in key feature development, such as around async fn support, or improvements to the trait system Improving our documentation and organization, helping to make it clearer what is going on at any given time, and how people can get involved.</description></item><item><title>rust-analyzer and libraryification</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-13-rust-analyzer-and-libraryification/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-13-rust-analyzer-and-libraryification/</guid><description>rust-analyzer and libraryification Zulip thread Proposal issue: rust-lang/rust#160 Additional notes: hackmd document Summary Goal of the meeting is to update on rust-analyzer plans and discuss taking the next step towards extracting &amp;ldquo;standalone libraries&amp;rdquo; that can be shared between rustc and rust-analyzer.
Update on rust-analyzer Rust-analyzer has made big strides and now includes
name resolution a partial type checker preliminary integration with chalk for trait solving as well as a shared lexer with rustc What does library-ification mean?</description></item><item><title>Target Tier Policy</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-20-target-tier-policy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-09-20-target-tier-policy/</guid><description>Target Tier Policy Zulip thread Proposal issue: rust-lang/rust#166 Original proposal with history Summary We should have an official, objective policy for adding new (tier 3) targets, and for raising targets to tier 2 (with rustup builds) or even tier 1.
Conclusion: Josh to revise policy based on feedback (done, see below) and subsequently submit as an RFC.
Motivation Rust developers regularly implement new targets in the Rust compiler, and reviewers of pull requests for such new targets would like a clear, consistent policy to cite for accepting or rejecting such targets.</description></item><item><title>Triage Working Group Discussion</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-07-08-triage-wg/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-07-08-triage-wg/</guid><description>Triage Working Group Discussion Zulip thread Summary Discussed ideas of a triage working group and how that might interact Discussed pnkfelix/nikomatsakis taking leave over next few weeks and what to do in the meantime Discussed the problems around review queues pnkfelix/nikomatsakis absence pnkfelix will be going on parental leave for 2 months starting July 15. nikomatsakis will be on PTO for a month or so, with limited availability. In the interim, nagisa has volunteered to run meetings.</description></item><item><title>Unify Dataflow Frameworks (#202)</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-09-unified-dataflow-framework/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-09-unified-dataflow-framework/</guid><description>Design Meeting 2019-11-08 Zulip Stream
Agenda Design doc: https://hackmd.io/@39Qr_z9cQhasi25sGjmFnA/Skvd9rztS
Explain the current state of things
We currently have two wholly separate APIs for dataflow, one for bit-vector problems and one that allows arbitrary transfer functions but still restricts the lattice to a powerset of indices. I want to merge these two to make code more DRY. The prototype implementation is described pretty thoroughly in the design doc, but maybe go over it a bit?</description></item><item><title>Working Group Retrospective</title><link>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-16-Working-Group-Retrospective/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-11-16-Working-Group-Retrospective/</guid><description>Working Group Retrospective Zulip stream or read on the Zulip archive What you are looking at We did a short survey before the meeting. The following notes were scraped from the 10 responses. I tried to de-duplicate common items. Towards the end, you will find some minutes that were taken during the meeting itself. &amp;ndash;nikomatsakis
Things to KEEP doing Working groups are useful Nice to know who to talk to in order to get involved this was more of a struggle before Providing opportunities for mentorship is good Scoping out small groups of decision makers for &amp;ldquo;in the weeds&amp;rdquo; decisions Weekly updates Dedicated Zulip streams: great to have ability to link/skim, even if most are muted Regular meetings are a good way to keep working groups focused Things to STOP doing Maybe fewer working groups, with more time/energy invested in each?</description></item></channel></rss>