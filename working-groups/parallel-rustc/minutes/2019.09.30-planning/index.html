<!doctype html><html lang=en><head><meta http-equiv=refresh content="0; url=https://forge.rust-lang.org/compiler/index.html"></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://rust-lang.github.io/compiler-team/>Rust Lang - Compiler Team</a></h2><style>nav ul a[href$="\2f compiler-team\2fworking-groups\2fparallel-rustc\2fminutes\2f 2019.09.30-planning\2f "]{color:#004ed0}</style><ul><li><p><strong>About</strong></p><ul><li><a href=/compiler-team/about/CODE_OF_CONDUCT/>Code of Conduct</a></li><li><a href=/compiler-team/about/chat-platform/>Chat Platform</a></li><li><a href=/compiler-team/about/steering-meeting/>Steering Meeting</a></li><li><a href=/compiler-team/about/triage-meeting/>Triage Meeting</a></li></ul></li><li><p><strong>Minutes</strong></p><ul><li><a href=/compiler-team/minutes/design-meeting/>Design Meetings</a></li><li><a href=/compiler-team/minutes/steering-meeting/>Steering Meetings</a></li><li><a href=/compiler-team/minutes/triage-meeting/>Triage Meetings</a></li></ul></li><li><p><strong>Procedures</strong></p><ul><li><a href=/compiler-team/procedures/>Documentation</a></li><li><a href=/compiler-team/procedures/crates/>Crates</a></li><li><a href=/compiler-team/procedures/call-for-participation/>Call for participation</a></li><li><a href=/compiler-team/procedures/form-new-working-group/>Form new working group</a></li></ul></li><li><p><a href=/compiler-team/working-groups/><strong>Working Groups</strong></a></p><ul><li><a href=/compiler-team/working-groups/async-await/>Async Await</a></li><li><a href=/compiler-team/working-groups/debugging/>Debugging</a></li><li><a href=/compiler-team/working-groups/diagnostics/>Diagnostics</a></li><li><a href=/compiler-team/working-groups/rustc-dev-guide/>Rustc Dev Guide</a></li><li><a href=/compiler-team/working-groups/llvm/>LLVM</a></li><li><a href=/compiler-team/working-groups/meta/>Meta</a></li><li><a href=/compiler-team/working-groups/mir-opt/>MIR-opt</a></li><li><a href=/compiler-team/working-groups/nll/>NLL</a></li><li><a href=/compiler-team/working-groups/parallel-rustc/>parallel rustc</a></li><li><a href=/compiler-team/working-groups/pgo/>PGO</a></li><li><a href=/compiler-team/working-groups/pipelining/>pipelining</a></li><li><a href=/compiler-team/working-groups/polonius/>polonius</a></li><li><a href=/compiler-team/working-groups/polymorphization/>polymorphization</a></li><li><a href=/compiler-team/working-groups/prioritization/>Prioritization</a></li><li><a href=/compiler-team/working-groups/rfc-2229/>rfc-2229</a></li><li><a href=/compiler-team/working-groups/rls-2.0/>rls-2.0</a></li><li><a href=/compiler-team/working-groups/self-profile/>Self Profile</a></li><li><a href=/compiler-team/working-groups/traits/>Traits</a></li></ul></li></ul></nav></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/compiler-team/svg/menu.svg alt=Menu>
</label><strong>2019.09.30-planning</strong></header><article class=markdown><h1 id=20190930-planning-meeting>2019.09.30 Planning Meeting</h1><p><a href=https://rust-lang.zulipchat.com/#narrow/stream/187679-t-compiler.2Fwg-parallel-rustc/topic/planning.20meeting>Zulip topic.</a></p><h2 id=roadmap>Roadmap</h2><ul><li>Sequential overhead<ul><li>Rerun perf benchmark with <code>-j1</code> (but not limiting parallel codegen) and identify hotspots<ul><li>Identify cases one by one and optimize</li></ul></li></ul></li><li>Overly fine-grained locking risks subtle ordering or dead-lock bugs<ul><li>Solution: audit</li></ul></li><li>Poor jobserver integration leading to overall poor scaling</li><li>Little public testing of correctness and performance<ul><li>Call for permance testing, asking for data with <code>-Ztimings</code><ul><li>requires us to have easy builds available, perhaps? At least useful for correctness</li></ul></li></ul></li><li>Rayon fork<ul><li>Do we feel the need to eliminate it?</li><li>Let&rsquo;s update it at least</li><li>Solution: Review the patches</li></ul></li><li>Documentation of key components<ul><li>What are the major sources of shared state and where is each documented?</li><li>How does jobserver integration work and can we improve on that?</li><li>Why do we have the Rayon fork?</li><li>How does thread-local state work &ndash; how does it get communicated to the workers?</li><li>How to handle multiple threads competing for a single query</li></ul></li><li>Unify parallel type-check and parallel code-gen into one framework<ul><li>Idea: alexcrichton can explain</li></ul></li></ul><h2 id=another-view-on-the-above-categorized-by-next-step>Another view on the above, categorized by &ldquo;next step&rdquo;</h2><ul><li>measure performance<ul><li>initial focus: seq overhead</li></ul></li><li>produce binary builds<ul><li>we as developers should be able to easily test out changes</li><li>document this for other developers too, not time to get everyone else involved!</li></ul></li><li>audit and document fine-grained locking<ul><li>produce a list of things to be audited</li><li>schedule a weekly meeting, recorded Zoom calls</li></ul></li><li>meetings with the &ldquo;explain, discuss, document&rdquo; format<ul><li>rayon fork features &ndash; do we need them?</li><li>parallel code-gen: how does it work, can it be unified?</li><li>jobserver integration</li><li>major sources of shared state</li><li><a href=https://hackmd.io/XDC24IlWT4OIxYdmIxH4Xg>pre-existing questions doc</a></li></ul></li><li>user involvement: start getting people using it<ul><li>create instructions on how to use alt builds for correctness checking<ul><li>or to roll your own build for perf testing</li></ul></li><li>how to gather data, where to submit</li></ul></li></ul><h2 id=scenarios-to-profile-and-measure>Scenarios to profile and measure</h2><ul><li>Whole crate graph builds with full parallelism. Should see significant wins in build time as well as CPU usage.<ul><li>Cargo</li><li>Rustc</li><li>sccache</li><li><code>script</code> from Servo</li><li>&mldr; this is also what the post on internals would ask for</li></ul></li><li>Run the <code>perf</code> suite with full parallelism enabled. Gets an idea for single-crate what is the benefit, when we have full parallelism, across a suite of scenarios (incremental, warm cache, cold cache, etc)</li><li>What is the impact of &ldquo;<code>-j1</code>&rdquo; w.r.t. non-codegen threads<ul><li>Run perf suite and look at <code>*-check</code> benchmarks</li></ul></li></ul></article></div><aside class="book-toc level-6 fixed"><nav id=TableOfContents><ul><li><a href=#roadmap>Roadmap</a></li><li><a href=#another-view-on-the-above-categorized-by-next-step>Another view on the above, categorized by &ldquo;next step&rdquo;</a></li><li><a href=#scenarios-to-profile-and-measure>Scenarios to profile and measure</a></li></ul></nav></aside></main></body></html>